#!/bin/sh
#|-*- mode:lisp -*-|#
#|Dump image for faster startup or Make Executable
exec ros -- $0 "$@"
|#

(ros:util)

(defpackage :ros.dump
  (:use :cl :ros.util))
(in-package :ros.dump)

(unless (find-package :uiop)
  #-quicklisp(require :uiop)
  #+quicklisp(ql:quickload :uiop :silent t))

;; fixme: why this is needed?
(mapc #'unintern '(dump-dir dump-output dump-executable main))
(defun dump-dir ()
  (merge-pathnames (format nil "impls/~A/~A/~A/dump/"
                           (uname-m) (uname) (ros:opt "impl"))
                   (homedir)))

(defun dump-output (params &optional force)
  (flet ((%dump (path &optional mode)
           (if (and (not force)
                    (probe-file path))
               ;; idea??
               ;; (y-or-n-p "Output file exists. Overwrite? [Y,n]")
               (if (eql mode :normal)
                   (format *error-output* "dump ~s already exists~%" (pathname-name path))
                   (format *error-output* "file ~s already exists~%" path))
               (progn
                 #+sbcl
                 (sb-ext:save-lisp-and-die path)
                 #+ccl
                 (ccl:save-application path)))))
    (cond
      ((null params)
       (format *error-output* "Usage: ~A [OPTIONS] dump output [-f] [-o OUTPUT] NAME~%" (ros:opt "argv0")))
      ((equal "-f" (first params))
       (dump-output (rest params) t))
      ((equal "-o" (first params))
       (if (> (length params) 1)
           (%dump (second params))
           (format *error-output* "Missing the pathname for an image.~%")))
      (t (let ((path (merge-pathnames (format nil "~A.~A" (first params) (ros.util:core-extention))
                                      (dump-dir))))
           (%dump (ensure-directories-exist path) :normal))))))

(defun dump-executable (params)
  (if params
      (let ((cmds (let ((*read-eval*))
                    (read-from-string
                     (format nil "(~A)"
                             (ros:opt "restart")))))
            (out (first params))
            (actual-out (or (and (equal (second params) "-o") ;; skimped ...
                                 (third params))
                            (first params))))
        (unless cmds
          (warn "dumping an executable without specifing the initial behaviour."))
        (when (equalp (pathname-type out) "ros")
          (let ((*package* (find-package :cl-user))
                main-list)
            (ros:script nil out)
            (setf main-list (let ((*package* (find-package :keyword)))
                              `((:entry ,(format nil "~S" ros:*main*))))
                  out (make-pathname :type #-win32 nil #+win32 "exe" :defaults actual-out)
                  cmds (if (first cmds)
                           (append cmds main-list)
                           main-list))))
        #+sbcl
        (sb-ext:save-lisp-and-die
         out
         :toplevel
         #'(lambda ()
             (setf ros:*argv* (rest sb-ext:*posix-argv*))
             (ros:run cmds))
         :executable t
         :save-runtime-options t)
        #+ccl
        (ccl:save-application
         out
         :toplevel-function
         #'(lambda ()
             (setf ros:*argv* (rest (ccl::command-line-arguments)))
             (ros:run cmds))
         :prepend-kernel t))
      (format *error-output* "Usage: ros dump executable help~%")))

(defvar *subcmds*
  '(("output" dump-output)
    #+(or sbcl ccl)
    ("executable" dump-executable)))

(defun main (subcmd cmd &rest r)
  (cond ((and (equal subcmd "main") r)
         (let ((func (second (assoc (first r) *subcmds* :test 'equal))))
           (if func
               (funcall func (rest r))
               (format *error-output* "'~A' is not a valid command for '~A' subcommand~%" (first r) cmd))))
        (t (format t "~{~a~%~}" (mapcar #'car *subcmds*)))))
